#!/usr/bin/env python
"""Performs metagene analyses separated into the following subprograms:

Generate
    Generates aligned regions of interest (ROIs) surrounding a landmark (e.g.
    a CDS start or a CDS end) for a set of transcripts.
    
    For all transcripts derived from the same gene and sharing the same
    genomic coordinate for the landmark, a maximal ROI is created such
    that all transcripts cover all positions in the ROI. If the transcript
    group does not contain the landmark (e.g. lacks a start or stop codon),
    it will be ignored.
    
    **Note**: if annotations are supplied as BED files, transcripts are not
    grouped by gene, because BED files don't contain this information.
    In this case one ROI is generated per transcript. This may or may not
    be what you want. You can filter later and decide.
    
    Output is saved as a tab-delimited text file indicating the gene name,
    a string representation of ROI, and an offset to align the ROI to all other
    ROIs in the file, if the ROI happens to be shorter than the specified region
    which occurs if any of the transcripts do not fully cover the desired ROI
    size.
    

Count
    This program generate metagene profiles, taking the following steps.
    
    1.  The **raw counts** at each position in each ROI (from the ``generate`` subprogram)
        are totaled to create a raw count vector.

    2.  A **normalized count vector** is generated from each raw count vector, by
        dividing the total number of counts occurring in a user-defined
        normalization sub-region of the ROI.
    
    3.  A **metagene average** is created by taking the median value at each position
        of each normalized count vector for which the ROI covers that position,
        and for which the corresponding raw-count vector contains at least a 
        minimum number of raw counts.
    
    Raw count vectors, normalized count vectors, and metagene profiles are all
    saved as tab-delimited text files, enabling subsequent plotting, filtering,
    or reanalysis.
    
    
Chart
    One or more metagene profiles generated by the ``count`` subprogram are plotted
    against each other. 


See command-line help for each subprogram for details on parameters for each 
"""


__author__ = "joshua"

import sys
import argparse
import functools
import numpy
from yeti.genomics.roitools import SegmentChain
from yeti.util.array_table import ArrayTable
from yeti.util.io.filters import NameDateWriter
from yeti.util.io.openers import get_short_name, argsopener, NullWriter
from yeti.util.scriptlib.argparsers import get_genome_array_from_args,\
                                                      get_transcripts_from_args,\
                                                      get_alignment_file_parser,\
                                                      get_annotation_file_parser,\
                                                      get_mask_file_parser,\
                                                      get_genome_hash_from_mask_args
from yeti.util.scriptlib.help_formatters import format_module_docstring
from yeti.util.services.decorators import catch_warnings

import inspect
printer = NameDateWriter(get_short_name(inspect.stack()[-1][1]))

#===============================================================================
# helper functions to generate/handle ROIs
#===============================================================================

def window_landmark(transcript,flank_upstream,flank_downstream,ref_delta=0,landmark=0):
    """Returns a region of interest (ROI) relative to a reference point specified
    in nucleotide distance from a landmark coordinate on a transcript.
    
    Parameters
    ----------
    transcript : |Transcript|
        Transcript on which to generate region of interest
    
    flank_upstream : int
        Nucleotide length upstream to include in region
        of interest, if ``transcript`` includes it
    
    flank_downstream : int
        Nucleotide length downstream to include in region
        of interest, if ``transcript`` includes it
    
    ref_delta : int
        Offset from the landmark to the reference point. If 0, the landmark
        is the reference point. Default: 0
    
    landmark : int
        Position of the landmark on ``transcript``, in transcript-centric coordinates
    
    
    Returns
    -------
    |SegmentChain|
        ROI surrounding landmark
    
    int
        offset to ROI to ``flank_upstream``, if ``transcript`` itself
        wasn't long enough to include the entire flank

    int
        Genomic coordinate of reference point
    """
    if landmark + ref_delta >= flank_upstream:
        fiveprime_offset   = 0
        my_start = landmark + ref_delta - flank_upstream
    else:
        fiveprime_offset  = flank_upstream - landmark
        my_start = 0
    
    my_end = min(transcript.get_length(),landmark + ref_delta + flank_downstream)
    ivc    = transcript.get_subchain(my_start,my_end)
   
    if landmark + ref_delta == transcript.get_length():
        if transcript.spanning_segment.strand == "+":
            ref_point = (transcript.spanning_segment.chrom,transcript.spanning_segment.end,transcript.spanning_segment.strand)
        else:
            ref_point = (transcript.spanning_segment.chrom,transcript.spanning_segment.start - 1,transcript.spanning_segment.strand)
    else:
        ref_point = transcript.get_genomic_coordinate(landmark+ref_delta)

    return ivc, fiveprime_offset, ref_point
    
    
def window_cds_start(transcript,flank_upstream,flank_downstream,ref_delta=0):
    """Returns a region of interest (ROI) relative to a reference point specified
    in nucleotide distance from the start of a coding region on a transcript.
    Returns an empty |SegmentChain| with a zero offset if the |Transcript| has
    no cds_start (i.e. is annotated as non-coding)
    
    Parameters
    ----------
    transcript : |Transcript|
        Transcript on which to generate region of interest
    
    flank_upstream : int
        Nucleotide length upstream of cds_start to include in region
        of interest, if ``transcript`` includes it
    
    flank_downstream : int
        Nucleotide length downstream of  cds_start to include in region
        of interest, if ``transcript`` includes it
    
    ref_delta : int
        Offset from  cds_start to the reference point. If 0, the landmark
        is the reference point. Default: 0
    
    Returns
    -------
    |SegmentChain|
        ROI surrounding cds start
    
    int
        offset to ROI to ``flank_upstream``, if ``transcript`` itself
        wasn't long enough to include the entire flank

    int
        Genomic coordinate of reference point
    """
    if transcript.cds_start is None:
        return SegmentChain(), numpy.nan, numpy.nan

    return window_landmark(transcript,flank_upstream,flank_downstream,
                           ref_delta=ref_delta,
                           landmark=transcript.cds_start)


def window_cds_stop(transcript,flank_upstream,flank_downstream,ref_delta=0):
    """Returns a region of interest (ROI) relative to a reference point specified
    in nucleotide distance from the first position of the stop codon on a transcript.
    Returns an empty |SegmentChain| with a zero offset if the |Transcript| has
    no cds_start (i.e. is annotated as non-coding)
    
    Parameters
    ----------
    transcript : |Transcript|
        Transcript on which to generate region of interest
    
    flank_upstream : int
        Nucleotide length upstream of cds_stop to include in region
        of interest, if ``transcript`` includes it
    
    flank_downstream : int
        Nucleotide length downstream of cds_stop to include in region
        of interest, if ``transcript`` includes it
    
    ref_delta : int
        Offset from  cds_start to the reference point. If 0, the landmark
        is the reference point. Default: 0
    
    Returns
    -------
    |SegmentChain|
        ROI surrounding cds stop
    
    int
        offset to ROI to ``flank_upstream``, if ``transcript`` itself
        wasn't long enough to include the entire flank

    int
        Genomic coordinate of reference point
    """
    if transcript.cds_start is None:
        return SegmentChain(), numpy.nan, numpy.nan
    
    return window_landmark(transcript,flank_upstream,flank_downstream,
                           ref_delta=ref_delta,
                           landmark=transcript.cds_end-3)


def StartWindowFactory(ref_delta=0):
    """Function factory to create alignment window functions that choose
    nucleotide windows centered around a coordinate specified relative to the
    CDS start of a transcript. Functions returned may be passed to do_generate()
    as the parameter reference_point_func
    
    Parameters
    ----------
    ref_delta : int
        Desired reference point on transcript, specified in
        nucleotides from the annotated start codon
    
    Returns
    -------
    Function
    """
    return functools.partial(window_cds_start,ref_delta=ref_delta)


def StopWindowFactory(ref_delta=0):
    """Function factory to create alignment window functions that choose
    nucleotide windows centered around a coordinate specified relative to the
    CDS end of a transcript. Functions returned may be passed to do_generate()
    as the parameter reference_point_func
    
    Parameters
    ----------
    ref_delta : int
        Desired reference point on transcript, specified in
        nucleotides from the annotated stop codon
    
    Returns
    -------
    Function 
    """
    return functools.partial(window_cds_stop,ref_delta=ref_delta)


#===============================================================================
# Subprograms
#===============================================================================

# worked for yeast. need to test for Drosophila, which has >1 transcript/gene
def do_generate(transcripts,mask_hash,flank_upstream,flank_downstream,
                  reference_point_func=window_cds_start,
                  printer=NullWriter()):
    """Generate a file of regions of interest (ROIs) for use in `'count`' subprogram
    
    Parameters
    ----------
    transcripts : list<|Transcript|>
        A list of |Transcript| s, preferably with gene_id and
        transcript_id (e.g. from a GTF2 or GFF3), so that
        the each genomic position will only be counted once,
        even if represented in multiple transcripts. If
        these attributes are not present, every position 
        will be included
    
    mask_hash : |GenomeHash|
        |GenomeHash| containing regions to exclude from analysis
    
    flank_upstream : int
        Number of nucleotides upstream of reference point
        to include in ROI (in transcript coordinates)

    flank_downstream: int
        Number of nucleotides downstream of reference point
        to include in ROI (in transcript coordinates)
    
    reference_point_func : func
        Function yielding reference point in transcript.
        :py:func:`window_cds_start` and :py:func:`window_cds_stop` are provided,
        though any function that meets the following criteria can be used:
        
            1. It must take the same parameters as :py:func:`window_cds_stop`
            
            2. It must return the same types as :py:func:`window_cds_stop`

        Such functions could, for example, build reference points around
        peaks in ribosome density, nucleic acid sequence features, transcript
        start or end sites, or any property that can be deduced from a |Transcript|.
    
    printer : file-like
        filehandle to write logging info to
    
    Returns
    -------
    |ArrayTable|
        An |ArrayTable| containing a column of windows,
        and a column of offsets to align in those windows at their fiveprime ends,
        and a column indicating the overall window size, even if redundant
    
    list
        List of |SegmentChain| representing each ROI. These data are also
        represented as strings in the |ArrayTable|
    
    Notes
    -----         
    Not all genes will be included in the output if, for example, there isn't a
    position set common to all transcripts surrounding the given start codon
    """
    window_size = flank_upstream + flank_downstream
        
    dtmp = { "gene_id"           : [],
             "region"            : [],
             "masked"            : [],
             "alignment_offset"  : [],
             "window_size"       : [],
             "zero_point"        : [],
             }
    
    # build gene-transcript graph
    printer.write("Building gene-transcript graph...")
    gene_transcript = {}
    for tx_ivc in transcripts:
        gene_id = tx_ivc.get_gene()
        try:
            gene_transcript[gene_id].append(tx_ivc)
        except KeyError:
            gene_transcript[gene_id] = [tx_ivc]
    
    # for each gene, find maximal window in which all points
    # are represented in all transcripts. return IVC and offset
    c = -1
    export_rois = []
    for gene_id, txlist in sorted(gene_transcript.items()):
        c += 1
        if c % 1000 == 1:
            printer.write("Processed %s transcripts, included %s..." % (c,len(list(dtmp.values())[0])))
        my_roi    = None
        new_roi   = None
        my_offset = None
        ref_point_genome = None
        first_base = last_base = new_roi = zero_point_roi = None
        new_offset = None
        refpoints = []
        
        # initialize shared_position_set to be nonempty so we can use AND
        # to find the intersection all position sets
        my_tx = txlist[0]
        shared_position_set = my_tx.get_position_set()

        # find common positions
        for tx in txlist:
            try:
                my_roi, my_offset, genomic_refpoint = reference_point_func(tx,flank_upstream,flank_downstream)
                shared_position_set &= my_roi.get_position_set()
                refpoints.append(genomic_refpoint)
            except IndexError:
                printer.write("IndexError at %s, transcript %s: " % (gene_id,tx.get_name()))
        
        # if shared position set is non-null, define new ROI and offset
        if len(shared_position_set) > 0 and len(set(refpoints)) == 1:

            # define new ROI covering all positions common to all transcripts
            new_ivc_coordinates = [my_tx.get_segmentchain_coordinate(my_tx.spanning_segment.chrom,
                                                                     X,
                                                                     my_tx.spanning_segment.strand)
                                   for X in shared_position_set]

            first_base = min(new_ivc_coordinates)
            last_base  = max(new_ivc_coordinates) + 1 # end-inclusive to half-open
            new_roi = my_tx.get_subchain(first_base,last_base)
            if new_roi.spanning_segment.strand == "+":
                new_roi.attr["thickstart"] = genomic_refpoint[1]
                new_roi.attr["thickend"]   = genomic_refpoint[1] + 1
            else:
                new_roi.attr["thickstart"] = genomic_refpoint[1]
                new_roi.attr["thickend"]   = genomic_refpoint[1] + 1

            # having made sure that refpoint is same for all transcripts,
            # we use last ROI and last offset to find genomic reference point
            #
            # this fails if ref point is at the 3' end of the roi, 
            # so we test it explicitly
            if flank_upstream - my_offset == my_roi.get_length():
                new_offset = my_offset
                if my_roi.strand == "+":
                    ref_point_genome = my_roi.spanning_segment.end
                else:
                    ref_point_genome = my_roi.spanning_segment.start - 1
            else:
                ref_point_genome = my_roi.get_genomic_coordinate(flank_upstream - my_offset)[1]
                zero_point_roi = new_roi.get_segmentchain_coordinate(new_roi.spanning_segment.chrom,
                                                                     ref_point_genome,
                                                                     new_roi.spanning_segment.strand)
                new_offset = flank_upstream - zero_point_roi
    
            masks = mask_hash.get_overlapping_features(new_roi)
            mask_ivs = []
            for mask in masks:
                mask_ivs.extend(mask._segments)
            
            mask_ivc = SegmentChain(*mask_ivs)
            
            dtmp["gene_id"].append(gene_id)
            dtmp["window_size"].append(window_size)
            dtmp["region"].append(str(new_roi)) # need to cast to string to keep numpy from converting to array
            dtmp["masked"].append(str(mask_ivc))
            dtmp["alignment_offset"].append(new_offset)
            dtmp["zero_point"].append(flank_upstream)
            export_rois.append(new_roi)

    # convert to ArrayTable
    dtmp = ArrayTable(dtmp)
    printer.write("Processed %s transcripts total. Included %s." % (c+1,len(dtmp)))

    return dtmp, export_rois

@catch_warnings("ignore")
def do_count(roi_table,gnd,norm_start,norm_end,min_counts,printer=NullWriter()):
    """Counts the number of reads at each position in each ROI, and normalizes
    each resulting vector by the total number of counts in a normalization
    region specified by norm_start and norm_end
    
    Parameters
    ----------
    roi_table : |ArrayTable|
        |ArrayTable| specifying regions of interest, generated
        by :py:meth:`do_generate`
    
    gnd : instance of subclass of |AbstractGenomeArray|
        Count data
    
    norm_start : int
        Coordinate in ROI specifying normalization region start
    
    norm_end : int
        Coordinate in ROI specifying normalization region end
    
    min_counts : float
        Minimum number of counts in ROI to be included in metagene profile

    printer : file-like
        filehandle to write logging info to

        
    Returns
    -------
    :py:class:`numpy.ndarray`
        raw counts at each position (column) for each ROI (row)
    
    :py:class:`numpy.ndarray`
        counts at each position (column) for each ROI (row), normalized by
        the total number of counts in that row from norm_start to norm_end
    
    |ArrayTable|
        Metagene profile of median normalized counts at each position across
        all ROIs, and the number of genes included in the calculation of each
        median
    """
    window_size    = roi_table["window_size"][0]
    upstream_flank = roi_table["zero_point"][0]
    counts = numpy.ma.MaskedArray(numpy.tile(numpy.nan,(len(roi_table),window_size)))
    
    for i in range(len(roi_table)):
        if i % 1000 == 1:
            printer.write("Counted %s ROIs..." % (i))
            
        roi    = SegmentChain.from_str(roi_table["region"][i])
        mask   = SegmentChain.from_str(roi_table["masked"][i])
        roi.add_masks(*mask)
        offset = int(round((roi_table["alignment_offset"][i])))
        assert offset + roi.get_length() <= window_size
        counts[i,offset:offset+roi.get_length()] = roi.get_valid_counts(gnd)
    
    printer.write("Counted %s ROIs total." % (i+1))
        
    denominator = numpy.nansum(counts[:,norm_start:norm_end],1)
    norm_counts = (1.0*counts.T / denominator).T
    
    norm_counts = numpy.ma.masked_invalid(norm_counts)
    
    profile   = numpy.ma.median(norm_counts[denominator >= min_counts],axis=0)
    num_genes = ((~norm_counts.mask)[denominator >= min_counts]).sum(0) 
    
    profile_table = ArrayTable({ "metagene_average"     : profile,
                                 "regions_counted"      : num_genes,
                                 "x"                    : numpy.arange(-upstream_flank,window_size-upstream_flank),
                                })
    return counts, norm_counts, profile_table


def do_chart(sample_dict,landmark="landmark",title=None):
    """Plot metagene profiles
    
    Parameters
    ----------
    sample_dict : dict
        Dictionary mapping sample names to |ArrayTable| s containing metagene
        profile information from ``count`` subprogram
    
    landmark : str, optional
        Name of landmark at zero point (used for labeling X-axis)
        
    title : str or None, optional
        If not None, chart title
    
    Returns
    -------
    :py:class:`matplotlib.Figure`
    """
    import matplotlib
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt

    fig = plt.figure()
    min_x = numpy.inf
    max_x = -numpy.inf
    for k, v in sample_dict.items():
        plt.plot(v["x"],v["metagene_average"],label=k)
        min_x = min(min_x,min(v["x"]))
        max_x = max(max_x,max(v["x"]))
    
    plt.xlim(min_x,max_x)
    ylim = plt.gca().get_ylim()
    plt.ylim(0,ylim[1])
    
    plt.xlabel("Distance from %s (nt)" % landmark)
    plt.ylabel("Normalized read density (au)")
    
    if title is not None:
        plt.title(title)
    
    return fig
        

#===============================================================================
# PROGRAM BODY
#===============================================================================


def main(argv=sys.argv[1:]):
    """Command-line program
    
    Parameters
    ----------
    argv : list, optional
        A list of command-line arguments, which will be processed
        as if the script were called from the command line if
        :py:func:`main` is called directly.

        Default: sys.argv[1:] (actually command-line arguments)
    """
    
    alignment_file_parser  = get_alignment_file_parser(disabled=["normalize"])
    annotation_file_parser = get_annotation_file_parser()
    mask_file_parser = get_mask_file_parser()
    
    generator_help = "Create ROI file from genome annotation"
    generator_desc = format_module_docstring(do_generate.__doc__)
    
    count_help = "Count reads falling into regions of interest, normalize, and average into a metagene profile"
    count_desc = format_module_docstring(do_count.__doc__)

    chart_help = "Plot metagene profiles"
    chart_desc = format_module_docstring(do_chart.__doc__)

    parser = argparse.ArgumentParser(description=format_module_docstring(__doc__),
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    subparsers = parser.add_subparsers(title="subcommands",
                                       description="choose one of the following",
                                       dest="program")
    gparser    = subparsers.add_parser("generate",
                                       help=generator_help,
                                       description=generator_desc,
                                       parents=[annotation_file_parser,mask_file_parser])
    cparser    = subparsers.add_parser("count",
                                       help=count_help,
                                       description=count_desc,
                                       parents=[alignment_file_parser])
    pparser    = subparsers.add_parser("chart",
                                       help=chart_help,
                                       description=chart_desc)
    
    # generate subprogram options
    gparser.add_argument("--landmark",type=str,choices=("cds_start","cds_stop"),
                         default="cds_start",
                         help="Landmark from which reference point is specified (Default: cds_start)")
    gparser.add_argument("--reference_delta",type=int,default=0,
                         help="Distance in transcript nucleotides between reference point and landmark (Default: 0)")
    gparser.add_argument("--upstream",type=int,default=50,
                         help="Nucleotides to include upstream of reference point (Default: 50)")
    gparser.add_argument("--downstream",type=int,default=50,
                         help="Nucleotides to include downstream of reference point (Default: 50)")
    gparser.add_argument("outbase",type=str,
                         help="Basename for output files")
    
    # count subprogram options
    cparser.add_argument("roi_file",type=str,
                         help="Text file containing regions of interest and offsets, "+
                              "generated by the 'generate' subprogram.")
    cparser.add_argument("--min_counts",type=int,default=10,metavar="N",
                         help="Minimum counts required in normalization region "+
                              "to be included in metagene average (Default: 10)")
    cparser.add_argument("--norm_region",type=int,nargs=2,metavar="N",
                         default=(70,100),
                         help="Portion of ROI against which each individual profile"+
                              " will be normalized. Specify two integers, in nucleotide"+
                              " distance, from 5' end of ROI. (Default: 70 100)")
    cparser.add_argument("outbase",type=str,
                         help="Basename for output files")

    # chart subprogram arguments
    pparser.add_argument("outfile",type=str,
                         help="Name of output file. Format will be auto-detected"+
                         " from the extension. Valid options are png, svg, pdf, eps, et c.")
    pparser.add_argument("infiles",type=str,nargs="+",
                         help="One or more metagene profiles, generated by the"+
                              " count subprogram, which will be plotted together."
                         )
    pparser.add_argument("--labels",type=str,nargs="+",default=[],
                         help="Sample names for each metagene profile (optional).")
    pparser.add_argument("--title",type=str,default=None,
                         help="Title for chart (optional)")
    pparser.add_argument("--landmark",type=str,default=None,
                         help="Name of landmark at zero point (e.g. 'CDS start' or 'CDS stop'; optional)")

    
    args = parser.parse_args(argv)
    
    # 'generate' subprogram
    if args.program == "generate":
        printer.write("Generating ROI file...")
        if args.landmark == "cds_start":
            map_function = StartWindowFactory(args.reference_delta)
        elif args.landmark == "cds_stop":
            map_function = StopWindowFactory(args.reference_delta)
            
        # open annotations
        printer.write("Opening annotation files: %s..." % ", ".join(args.annotation_files))
        transcripts = get_transcripts_from_args(args,printer=printer)
        
        mask_hash = get_genome_hash_from_mask_args(args)
        
        # get ROIs
        printer.write("Generating regions of interest...")   
        roi_table, export_rois = do_generate(transcripts,
                                             mask_hash,
                                             args.upstream,
                                             args.downstream,
                                             reference_point_func=map_function,
                                             printer=printer)
        roi_file = "%s_rois.txt" % args.outbase
        bed_file = "%s_rois.bed" % args.outbase
        printer.write("Saving to ROIs %s..." % roi_file)
        with argsopener(roi_file,args,"w") as roi_fh:
            roi_table.to_file(roi_fh)
            roi_fh.close()
            
        printer.write("Saving BED output as %s..." % bed_file)
        with argsopener(bed_file,args,"w") as bed_fh:
            for roi in export_rois:
                bed_fh.write(roi.as_bed())
        
            bed_fh.close()
    
    # 'count' subprogram
    elif args.program == "count":
        printer.write("Opening ROI file %s..." % args.roi_file)
        with open(args.roi_file) as fh:
            roi_table = ArrayTable.from_file(fh)
            fh.close()
        
        # open count files
        gnd = get_genome_array_from_args(args,printer=printer,disabled=["normalize"])
        
        # count
        printer.write("Counting...")
        counts, norm_counts, profile_table = do_count(roi_table,
                                                      gnd,
                                                      args.norm_region[0],
                                                      args.norm_region[1],
                                                      args.min_counts,
                                                      printer=printer)
        
        # save
        count_fn     = "%s_rawcounts.txt" % args.outbase
        normcount_fn = "%s_normcounts.txt" % args.outbase
        profile_fn   = "%s_metagene_profile.txt" % args.outbase
        printer.write("Saving counts to %s..." % count_fn)
        numpy.savetxt(count_fn,counts,delimiter="\t",fmt='%.8f')
        printer.write("Saving normalized counts to %s..." % normcount_fn)
        numpy.savetxt(normcount_fn,norm_counts,delimiter="\t")
        printer.write("Saving metagene profile to %s..." % profile_fn)
        with argsopener(profile_fn,args,"w") as profile_out:
            profile_table.to_file(profile_out,
                                  keyorder=["x","metagene_average","regions_counted"],
                                  formatters={numpy.float64  : '{:.8f}'.format,
                                              numpy.float32  : '{:.8f}'.format,
                                              numpy.float128 : '{:.8f}'.format,
                                  }
                                  )
            profile_out.close()
        
    # 'plot' subprogram
    elif args.program == "chart":
        assert len(args.labels) in (0,len(args.infiles))
        if len(args.labels) == len(args.infiles):
            samples = { K : ArrayTable.from_file(open(V)) for K,V in zip(args.labels,args.infiles)}
        else:
            samples = { get_short_name(V) : ArrayTable.from_file(open(V)) for V in args.infiles }
        
        figure = do_chart(samples,title=args.title,landmark=args.landmark)
        printer.write("Saving to %s..." % args.outfile)
        figure.savefig(args.outfile)

    printer.write("Done.")

if __name__ == "__main__":
    main()
