#!/usr/bin/env python
"""Utilities for handling sets.

Exported functions
------------------
:py:func:`merge_sets`
    Recursively merge of sets based upon common members, until all groups
    sharing common members are merged.

:py:func:`get_random_sets`
    Generate random sets of members
"""
import numpy.random
import copy

def merge_sets(list_of_sets,verbose=False,printer=None):
    """Merges sets in a list if they have one or more common member,
    until all groups sharing common members are merged.
    
    Merging takes places as follows:
    
        1.  All members in all sets are counted
    
        2.  All sets containing more than one member are merged via
            a call to :func:`_merge_sets`
            
        3.  A set of unmerged single-member sets is generated by finding all
            members that appear in multi-member sets after step (2), and subtracting
            this set from the set generated in step (1)
            
        4.  The list of single- and multi-member sets are concatenated to create
            a final list
    
    Repeat steps 1-4 until the number of sets is unchanged  
    
    Parameters
    ----------
    list_of_sets : list
        List of sets of hashable items

    verbose : bool, optional
        If `True`, status is printed. (Default: `False`)

    printer : file-like
        Writer to which status is sent, as string, if verbose is `True`.
        (Default: :obj:`sys.stdout`)

    Returns
    -------
    list
        list of merged sets
    """
    # first, simplify sets to remove redundancy
    list_of_sets = list(set([tuple(sorted(X)) for X in list_of_sets]))
    list_of_sets = [set(X) for X in list_of_sets]
    
    # count up all members
    all_members = set()
    for my_set in list_of_sets:
        all_members |= my_set
        
    # ignore singletons
    #multis = filter(lambda x: len(x) > 1,list_of_sets)
    multis = [X for X in list_of_sets if len(X) > 1]
    if verbose is True:
        stmp = "Starting with %s sets, %s distinct members, and %s groups with multiple items..." % (len(list_of_sets), len(all_members),len(multis))
        if printer is not None:
            printer.write(stmp)
        else:
            printer.write(stmp)
        
    merged_multis = _merge_sets(multis,verbose=verbose,printer=printer)
    merged_members = set()
    for my_set in merged_multis:
        merged_members |= my_set
        
    unmerged_members = all_members - merged_members
    unmerged_sets = [set([X]) for X in unmerged_members]
    return merged_multis + unmerged_sets
    
def _merge_sets(list_of_sets,verbose=False,printer=None,callback=merge_sets):
    """Inner loop function for :func:`merge_sets`.

    Parameters
    ----------
    list_of_sets : list
        List of sets of hashable items to merge

    verbose : bool, optional
        If `True`, status is printed (Default: `False`)

    printer : file-like
        Writer to which status is sent, as string, if verbose is True.
        (Default: :obj:`sys.stdout`)

    callback : function, optional
        Callback function for next recursive call (Default: :func:`merge_sets`)

    Returns
    -------
    list
        list of partially merged sets
    """
    if verbose is True:
        stmp = "Starting with %s sets..." % len(list_of_sets)
        if printer is not None:
            printer.write(stmp)
        else:
            printer.write(stmp)
    new_sets = []
    for set_a in list_of_sets:
        new_set = set(copy.deepcopy(set_a))
        for set_b in list_of_sets:
            set_b = set(set_b)
            if len(new_set & set_b) > 0:
                new_set |= set_b
        new_sets.append(tuple(new_set))
    ltmp = list(set([tuple(X) for X in new_sets]))
    if len(ltmp) == len(list_of_sets):
        return [set(X) for X in set(ltmp)]
    else:
        return callback(ltmp,verbose,printer)

def get_random_sets(num_sets,max_len=3,members=list("abcdefghijklmnop")):
    """Generates random sets of members

    Parameters
    ----------
    num_sets : int
        number of sets to generate

    max_len : int
        maximum length for each set

    members : list-like
        Sequence of hashable members to put in each set
        (Default: letters a-p)

    Returns
    -------
    list
        List of generated sets
    """
    lout = []
    for _ in range(num_sets):
        num_in_set = numpy.random.randint(1,max_len+1)
        stmp = set()
        for _ in range(num_in_set):
            stmp |= { members[numpy.random.randint(len(members))] }
        lout.append(stmp)
    return lout

   
